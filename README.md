# CS-250_AGILE_Overview

## My Software Development Philosophy
This readme addresses some of the big ideas in computer science. Discussing how I translate user needs into functional products, my preferred methodologies and my teamwork philosophy.

## From User Need to Working Software
**How do I interpret user needs and implement them into a program? How does creating "user stories" help with this?**

My process stems from a simple idea: **empathy**. To build effective software, I must first understand the user's problem from their perspective. By excersizing active listening techniques, asking clarifying questions and focusing on the "WHY" behind a feature request, not just the "WHAT". The ultimate goal is translating real world needs into technical requirements.
This is where user stories thrive. A user story frames a requirement from the users view-point, typically in a format such as: "As a [who is the desired user], I want to [describe the action to be performed] so that I can [do this super awesome thing]".

**User Stories are Helpful in these Three Ways**
- Keep the Focus on the Value: Why is the feature being built? Ensure the deliverables provide real value to the user.
- Foster Collaboration: Provide simple, common language descriptions that are easy to understand by both technical and non-technical users.
- Enable Incremental Development: Break down large and complex projects into small, manageable and testable chunks of work.

## My Development Approach
**How do I approach developing programs? What Agile processes do I hope to incorporate into my future development work?**

My approach to program development is as an iterative cycle of planning, building, testing and refining. Rather than trying to build a perfect, complete application in one attempt, I believe that starting in what is your Minimum Viable Product and building based on feedback and growing requirements.

This iterative philosphy is in close alignment with the Agile methodologies. In future work I hope that I am able to continue to incorporate more Agile processes.
- Scrum: I like the structured approach of sprints. The routine of planning, review and daily stand-ups creates an environment that fosters focus, transparency and continuous improvement.
- Kanban: I enjoy the visual nature of the Kanban boards. They help manage the workflow and provide an ability to limit work in progress. Kanban helps remove bottlenecks and ensure smooth project flow.
- Continuous Integration/Continous Deployment: Automate testing and development. Support Agiles goal of small, frequent updates to the user.

## Being an Effective Team Member
**What does it mean to be a good team member in software development?**

Being a good team member in software development goes far beyond just writing good code. It's about elevating the entire team. To me, it means being a communicator, a collaborator, and a reliable partner.
- Clear Communication: This involves not only articulating my own ideas clearly but also actively listening to others. It means providing constructive, respectful feedback during code reviews and writing clear documentation so others can understand my work.
- Proactive Collaboration: This is about actively seeking opportunities to work together, whether through pair programming to solve a tough problem or simply offering help when a teammate is stuck. Itâ€™s about sharing knowledge freely and understanding that the team's success is my success.
- Reliability and Ownership: A good team member is dependable. They take ownership of their tasks from start to finish, write clean, maintainable code that won't create problems for others, and meet their commitments.
